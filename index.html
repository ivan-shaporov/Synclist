<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Checklist</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M9 11l3 3L22 4'/%3E%3Cpath d='M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11'/%3E%3C/svg%3E">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 16px;
      background: #fafafa;
    }

    h1 {
      margin-bottom: 16px;
    }

    h2 {
      margin-top: 24px;
      margin-bottom: 8px;
      font-size: 1.1rem;
      color: #444;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    li {
      display: flex;
      align-items: center;
      padding: 10px 6px;
      border-bottom: 1px solid #ddd;
      font-size: 1rem;
      background: #fff;
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin-right: 12px;
      flex-shrink: 0;
    }
    
    #status {
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 10px;
    }

    .delete-btn {
      display: none;
      margin-left: auto;
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .edit-mode .delete-btn {
      display: block;
    }
  </style>
</head>
<body>
  
  <div id="addItemContainer" style="display: none; gap: 8px; margin-bottom: 16px;">
    <input type="text" id="newItemInput" placeholder="Add new item..." style="flex-grow: 1; padding: 8px; font-size: 1rem;">
    <button id="addItemBtn" style="padding: 8px 16px; font-size: 1rem;">Add</button>
  </div>

  <div id="status">Connecting...</div>

  <h2>Pending</h2>
  <ul id="unchecked"></ul>

  <h2>Done</h2>
  <ul id="checked"></ul>

  <script>
    // --- CONFIGURATION ---
    // SAS token is now read from the URL hash (e.g. index.html#https://...)
    const PARTITION_KEY = "shared-list";
    // ---------------------

    const urlParams = new URLSearchParams(window.location.search);
    const isEditMode = urlParams.has('edit');

    // Local fallback data
    let sampleItems = [
      { id: "1", text: "bread", checked: false, order: 100 },
      { id: "2", text: "eggs", checked: false, order: 99 },
      { id: "3", text: "milk", checked: false, order: 98 }
    ];

    let items = [];

    // Helper to parse URL
    function getTableParts() {
      // Read from URL hash: #https://...
      const hash = window.location.hash.substring(1); // Remove #
      if (!hash) return null;

      try {
        const urlObj = new URL(hash);
        const baseUrl = urlObj.origin + urlObj.pathname;
        const sasToken = urlObj.search;
        return { baseUrl, sasToken };
      } catch (e) {
        console.error("Invalid SAS URL in hash", e);
        return null;
      }
    }

    async function fetchItems() {
      const parts = getTableParts();
      if (!parts) {
        console.log("No SAS token configured. Using local mode.");
        document.getElementById('status').innerText = "Offline Mode (incomplete url)";
        items = [...sampleItems];
        render();
        return;
      }

      document.getElementById('status').innerText = "Syncing...";
      
      try {
        const response = await fetch(`${parts.baseUrl}${parts.sasToken}`, {
          headers: { "Accept": "application/json;odata=nometadata" }
        });
        
        if (!response.ok) throw new Error(`Error fetching: ${response.statusText}`);
        
        const data = await response.json();
        
        if (data.value.length === 0) {
          if (!isEditMode) {
            console.log("Table empty. View mode will not seed.");
            items = [];
            render();
            document.getElementById('status').innerText = "Empty";
            return;
          }

          console.log("Table empty, seeding with sample items...");
          items = [...sampleItems];
          render(); // Show immediately
          
          // Upload all items sequentially
          document.getElementById('status').innerText = "Seeding cloud...";
          for (const item of items) {
            await updateItemInCloud(item);
          }
          document.getElementById('status').innerText = "Seeded & Synced";
        } else {
          // Map Azure Table entities to our format
          items = data.value.map(entity => ({
            id: entity.RowKey,
            text: entity.Text || entity.text, // Handle case sensitivity
            checked: entity.Checked || entity.checked || false,
            order: entity.Order || entity.order || 0,
            etag: entity['odata.etag']
          }));
          document.getElementById('status').innerText = "Synced";
          render();
        }
      } catch (err) {
        console.error(err);
        document.getElementById('status').innerText = "Error syncing";
      }
    }

    async function updateItemInCloud(item) {
      const parts = getTableParts();
      if (!parts) return;

      // Construct Entity URL: Base(PartitionKey='...', RowKey='...')?SAS
      const entityUrl = `${parts.baseUrl}(PartitionKey='${PARTITION_KEY}',RowKey='${item.id}')${parts.sasToken}`;
      
      const payload = {
        PartitionKey: PARTITION_KEY,
        RowKey: item.id,
        Text: item.text,
        Checked: item.checked,
        Order: item.order
      };

      try {
        // IMPORTANT:
        // - In view mode, we must NOT use PUT without If-Match because Azure Tables treats it as InsertOrReplace
        //   (requires Add permission). That causes 403 with the `webqueryupdate` (ru) policy.
        // - Use MERGE + If-Match for update-only behavior.
        const commonHeaders = {
          "Content-Type": "application/json",
          "Accept": "application/json;odata=nometadata",
          "x-ms-date": new Date().toUTCString(),
          "x-ms-version": "2019-02-02"
        };

        if (!isEditMode) {
          await fetch(entityUrl, {
            method: "MERGE",
            headers: {
              ...commonHeaders,
              "If-Match": "*"
            },
            body: JSON.stringify(payload)
          });
          return;
        }

        // Edit mode: allow inserts/replace (requires Add+Update on the SAS policy)
        await fetch(entityUrl, {
          method: "PUT", 
          headers: {
            ...commonHeaders
          },
          body: JSON.stringify(payload)
        });
      } catch (err) {
        console.error("Failed to update item", err);
        document.getElementById('status').innerText = "Failed to save change to cloud";
      }
    }

    async function deleteItem(id) {
      if (!confirm("Delete this item?")) return;

      const itemIndex = items.findIndex(i => i.id === id);
      if (itemIndex === -1) return;
      
      const item = items[itemIndex];
      items.splice(itemIndex, 1);
      render();

      if (getTableParts()) {
        await deleteItemFromCloud(item);
      } else {
        const sampleIndex = sampleItems.findIndex(i => i.id === id);
        if (sampleIndex !== -1) sampleItems.splice(sampleIndex, 1);
      }
    }

    async function deleteItemFromCloud(item) {
      const parts = getTableParts();
      if (!parts) return;

      // Construct Entity URL
      const entityUrl = `${parts.baseUrl}(PartitionKey='${PARTITION_KEY}',RowKey='${item.id}')${parts.sasToken}`;
      
      try {
        await fetch(entityUrl, {
          method: "DELETE",
          headers: {
            "Accept": "application/json",
            "If-Match": "*" // Force delete regardless of etag
          }
        });
      } catch (err) {
        console.error("Failed to delete item", err);
        document.getElementById('status').innerText = "Failed to delete from cloud";
      }
    }

    function render() {
      const uncheckedEl = document.getElementById("unchecked");
      const checkedEl = document.getElementById("checked");

      uncheckedEl.innerHTML = "";
      checkedEl.innerHTML = "";

      // Sort: Unchecked (Order DESC), Checked (Order DESC)
      const uncheckedItems = items.filter(i => !i.checked).sort((a, b) => b.order - a.order);
      const checkedItems = items.filter(i => i.checked).sort((a, b) => b.order - a.order);

      uncheckedItems.forEach(item => uncheckedEl.appendChild(renderItem(item)));
      checkedItems.forEach(item => checkedEl.appendChild(renderItem(item)));
    }

    function renderItem(item) {
      const li = document.createElement("li");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = item.checked;
      checkbox.addEventListener("change", () => toggleItem(item.id));

      li.appendChild(checkbox);
      li.appendChild(document.createTextNode(item.text));

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.className = "delete-btn";
      deleteBtn.addEventListener("click", () => deleteItem(item.id));
      li.appendChild(deleteBtn);

      return li;
    }

    async function toggleItem(id) {
      const item = items.find(i => i.id === id);
      if (!item) return;

      // Optimistic update
      item.checked = !item.checked;
      item.order = Date.now(); // Move to top logic
      
      render();

      // Persist
      if (getTableParts()) {
        await updateItemInCloud(item);
      } else {
        // Update local fallback
        const sampleItem = sampleItems.find(i => i.id === id);
        if (sampleItem) {
            sampleItem.checked = item.checked;
            sampleItem.order = item.order;
        }
      }
    }

    async function addItem() {
      const input = document.getElementById("newItemInput");
      const text = input.value.trim();
      if (!text) return;

      const newItem = {
        id: Date.now().toString(),
        text: text,
        checked: false,
        order: Date.now()
      };

      items.push(newItem);
      input.value = "";
      render();

      if (getTableParts()) {
        await updateItemInCloud(newItem);
      } else {
        sampleItems.push(newItem);
      }
    }

    document.getElementById("addItemBtn").addEventListener("click", addItem);
    document.getElementById("newItemInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") addItem();
    });

    // Check for edit mode
    if (isEditMode) {
      document.getElementById('addItemContainer').style.display = 'flex';
      document.body.classList.add('edit-mode');
    }

    // Initial load
    fetchItems();
    
    // Poll every 5 seconds if online, but only when visible to save battery
    setInterval(() => {
      if (!document.hidden && getTableParts()) fetchItems();
    }, 5000);

  </script>

</body>
</html>
