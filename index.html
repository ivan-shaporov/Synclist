<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Synclist</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M9 11l3 3L22 4'/%3E%3Cpath d='M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11'/%3E%3C/svg%3E">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 16px;
      background: #fafafa;
    }

    h1 {
      margin-bottom: 16px;
    }

    h2 {
      margin-top: 24px;
      margin-bottom: 8px;
      font-size: 1.1rem;
      color: #444;
    }

    h3 {
      margin-top: 10px;
      margin-bottom: 6px;
      font-size: 0.95rem;
      color: #666;
      font-weight: 600;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    li {
      display: flex;
      align-items: center;
      padding: 10px 6px;
      border-bottom: 1px solid #ddd;
      font-size: 1rem;
      background: #fff;
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin-right: 12px;
      flex-shrink: 0;
    }
    
    #status {
      font-size: 0.8rem;
      color: #666;
      margin-bottom: 10px;
    }

    .delete-btn {
      display: none;
      margin-left: auto;
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .edit-mode .delete-btn {
      display: block;
    }
  </style>
</head>
<body>

  <div id="globalAddContainer" style="display: none; gap: 8px; margin-bottom: 16px;">
    <input type="text" id="newPartitionInput" placeholder="List name..." style="width: 180px; padding: 8px; font-size: 1rem;">
    <input type="text" id="newGlobalItemInput" placeholder="Add new item..." style="flex-grow: 1; padding: 8px; font-size: 1rem;">
    <button id="addGlobalItemBtn" style="padding: 8px 16px; font-size: 1rem;">Add</button>
  </div>


  <div id="status">Connecting...</div>

  <div id="lists"></div>

  <script>
    // --- CONFIGURATION ---
    // SAS token is now read from the URL hash (e.g. index.html#https://...)
    // ---------------------

    const urlParams = new URLSearchParams(window.location.search);
    const isEditMode = urlParams.has('edit');

    const draftTextByPartition = new Map();

    function sasHasPartitionFilter(sasToken) {
      const query = (sasToken || "").startsWith("?") ? sasToken.slice(1) : (sasToken || "");
      if (!query) return false;

      const params = new URLSearchParams(query);

      // SAS-scoped partition key range parameters (Azure Tables SAS)
      for (const [key] of params.entries()) {
        const k = key.toLowerCase();
        if (k === 'spk' || k === 'epk' || k === 'sprk' || k === 'eprk') return true;
      }

      return false;
    }

    function updateGlobalAdderVisibility() {
      const el = document.getElementById('globalAddContainer');
      if (!el) return;

      if (!isEditMode) {
        el.style.display = 'none';
        return;
      }

      const parts = getTableParts();
      // Show when offline OR when online without a PartitionKey filter.
      el.style.display = (!parts || !sasHasPartitionFilter(parts.sasToken)) ? 'flex' : 'none';
    }

    // Local fallback data
    let sampleItems = [
      { id: "1", partitionKey: "grocery", text: "bread", checked: false, order: 100 },
      { id: "2", partitionKey: "grocery", text: "eggs", checked: false, order: 99 },
      { id: "3", partitionKey: "grocery", text: "milk", checked: false, order: 98 },
      { id: "4", partitionKey: "errands", text: "walk the dog", checked: false, order: 97 },
    ];

    let items = [];

    // Helper to parse URL
    function getTableParts() {
      // Read from URL hash: #https://...
      const hash = window.location.hash.substring(1); // Remove #
      if (!hash) return null;

      try {
        const urlObj = new URL(hash);
        const baseUrl = urlObj.origin + urlObj.pathname;
        const sasToken = urlObj.search;
        return { baseUrl, sasToken };
      } catch (e) {
        console.error("Invalid SAS URL in hash", e);
        return null;
      }
    }

    async function fetchItems() {
      const parts = getTableParts();
      updateGlobalAdderVisibility();
      if (!parts) {
        console.log("No SAS token configured. Using local mode.");
        document.getElementById('status').innerText = "Offline Mode (incomplete url)";
        items = [...sampleItems];
        render();
        return;
      }

      document.getElementById('status').innerText = "Syncing...";
      
      try {
        const response = await fetch(`${parts.baseUrl}${parts.sasToken}`, {
          headers: { "Accept": "application/json;odata=nometadata" }
        });
        
        if (!response.ok) throw new Error(`Error fetching: ${response.statusText}`);
        
        const data = await response.json();
        
        if (data.value.length === 0) {
          if (!isEditMode) {
            console.log("Table empty. View mode will not seed.");
            items = [];
            render();
            document.getElementById('status').innerText = "Empty and readonly";
            return;
          }

          console.log("Table empty, seeding with sample items...");
          items = [...sampleItems];
          render(); // Show immediately
          
          // Upload all items sequentially
          document.getElementById('status').innerText = "Seeding cloud...";
          for (const item of items) {
            await updateItemInCloud(item);
          }
          document.getElementById('status').innerText = "Seeded & Synced";
        } else {
          // Map Azure Table entities to our format
          items = data.value.map(entity => ({
            id: entity.RowKey,
            partitionKey: entity.PartitionKey,
            text: entity.Text || entity.text, // Handle case sensitivity
            checked: entity.Checked || entity.checked || false,
            order: entity.Order || entity.order || 0,
            etag: entity['odata.etag']
          }));
          document.getElementById('status').innerText = "Synced";
          render();
        }
      } catch (err) {
        console.error(err);
        document.getElementById('status').innerText = "Error syncing";
      }
    }

    async function updateItemInCloud(item) {
      const parts = getTableParts();
      if (!parts) return;

      const pk = item.partitionKey;

      // Construct Entity URL: Base(PartitionKey='...', RowKey='...')?SAS
      const entityUrl = `${parts.baseUrl}(PartitionKey='${pk}',RowKey='${item.id}')${parts.sasToken}`;
      
      const payload = {
        PartitionKey: pk,
        RowKey: item.id,
        Text: item.text,
        Checked: item.checked,
        Order: item.order
      };

      try {
        // IMPORTANT:
        // - In view mode, we must NOT use PUT without If-Match because Azure Tables treats it as InsertOrReplace
        //   (requires Add permission). That causes 403 with the `webqueryupdate` (ru) policy.
        // - Use MERGE + If-Match for update-only behavior.
        const commonHeaders = {
          "Content-Type": "application/json",
          "Accept": "application/json;odata=nometadata",
          "x-ms-date": new Date().toUTCString(),
          "x-ms-version": "2019-02-02"
        };

        if (!isEditMode) {
          await fetch(entityUrl, {
            method: "MERGE",
            headers: {
              ...commonHeaders,
              "If-Match": "*"
            },
            body: JSON.stringify(payload)
          });
          return;
        }

        // Edit mode: allow inserts/replace (requires Add+Update on the SAS policy)
        await fetch(entityUrl, {
          method: "PUT", 
          headers: {
            ...commonHeaders
          },
          body: JSON.stringify(payload)
        });
      } catch (err) {
        console.error("Failed to update item", err);
        document.getElementById('status').innerText = "Failed to save change to cloud";
      }
    }

    async function deleteItem(id) {
      if (!confirm("Delete this item?")) return;

      const itemIndex = items.findIndex(i => i.id === id);
      if (itemIndex === -1) return;
      
      const item = items[itemIndex];
      items.splice(itemIndex, 1);
      render();

      if (getTableParts()) {
        await deleteItemFromCloud(item);
      } else {
        const sampleIndex = sampleItems.findIndex(i => i.id === id);
        if (sampleIndex !== -1) sampleItems.splice(sampleIndex, 1);
      }
    }

    async function deleteItemFromCloud(item) {
      const parts = getTableParts();
      if (!parts) return;

      const pk = item.partitionKey;

      // Construct Entity URL
      const entityUrl = `${parts.baseUrl}(PartitionKey='${pk}',RowKey='${item.id}')${parts.sasToken}`;
      
      try {
        await fetch(entityUrl, {
          method: "DELETE",
          headers: {
            "Accept": "application/json",
            "If-Match": "*" // Force delete regardless of etag
          }
        });
      } catch (err) {
        console.error("Failed to delete item", err);
        document.getElementById('status').innerText = "Failed to delete from cloud";
      }
    }

    function render() {
      const listsEl = document.getElementById("lists");

      // Preserve any in-progress typing in add inputs across re-renders.
      let activeDraftPartition = null;
      let activeSelection = null;
      const activeEl = document.activeElement;
      if (activeEl && activeEl instanceof HTMLInputElement) {
        const pk = activeEl.dataset && activeEl.dataset.addPartition;
        if (pk) {
          activeDraftPartition = pk;
          activeSelection = {
            start: activeEl.selectionStart,
            end: activeEl.selectionEnd
          };
        }
      }

      document.querySelectorAll('input[data-add-partition]').forEach((input) => {
        draftTextByPartition.set(input.dataset.addPartition, input.value);
      });

      listsEl.innerHTML = "";

      const partitions = new Map();
      for (const item of items) {
        const pk = item.partitionKey || "(no partition)";
        if (!partitions.has(pk)) partitions.set(pk, []);
        partitions.get(pk).push(item);
      }

      const partitionKeys = Array.from(partitions.keys()).sort((a, b) => a.localeCompare(b));

      for (const pk of partitionKeys) {
        const section = document.createElement("section");

        const title = document.createElement("h2");
        title.textContent = pk;
        section.appendChild(title);

        const partitionItems = partitions.get(pk);

        // Sort: Unchecked (Order DESC), Checked (Order DESC)
        const uncheckedItems = partitionItems.filter(i => !i.checked).sort((a, b) => b.order - a.order);
        const checkedItems = partitionItems.filter(i => i.checked).sort((a, b) => b.order - a.order);

        const pendingTitle = document.createElement("h3");
        pendingTitle.textContent = "Pending";
        section.appendChild(pendingTitle);

        const pendingList = document.createElement("ul");
        uncheckedItems.forEach(item => pendingList.appendChild(renderItem(item)));
        section.appendChild(pendingList);

        const doneTitle = document.createElement("h3");
        doneTitle.textContent = "Done";
        section.appendChild(doneTitle);

        const doneList = document.createElement("ul");
        checkedItems.forEach(item => doneList.appendChild(renderItem(item)));
        section.appendChild(doneList);

        if (isEditMode) {
          section.appendChild(renderAddRow(pk));
        }

        listsEl.appendChild(section);
      }

      if (activeDraftPartition) {
        const newActive = document.querySelector(`input[data-add-partition="${CSS.escape(activeDraftPartition)}"]`);
        if (newActive) {
          newActive.focus();
          if (activeSelection && typeof activeSelection.start === 'number' && typeof activeSelection.end === 'number') {
            try {
              newActive.setSelectionRange(activeSelection.start, activeSelection.end);
            } catch {
              // Some browsers can throw if selection is invalid; ignore.
            }
          }
        }
      }
    }

    function renderAddRow(partitionKey) {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.gap = "8px";
      row.style.marginTop = "10px";
      row.style.marginBottom = "16px";

      const input = document.createElement("input");
      input.type = "text";
      input.placeholder = "Add new item...";
      input.dataset.addPartition = partitionKey;
      input.style.flexGrow = "1";
      input.style.padding = "8px";
      input.style.fontSize = "1rem";
      input.value = draftTextByPartition.get(partitionKey) || "";
      input.addEventListener("input", () => {
        draftTextByPartition.set(partitionKey, input.value);
      });

      const btn = document.createElement("button");
      btn.textContent = "Add";
      btn.style.padding = "8px 16px";
      btn.style.fontSize = "1rem";

      const submit = () => addItemToPartition(partitionKey, input);
      btn.addEventListener("click", submit);
      input.addEventListener("keypress", (e) => {
        if (e.key === "Enter") submit();
      });

      row.appendChild(input);
      row.appendChild(btn);
      return row;
    }

    function renderItem(item) {
      const li = document.createElement("li");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = item.checked;
      checkbox.addEventListener("change", () => toggleItem(item));

      li.appendChild(checkbox);
      li.appendChild(document.createTextNode(item.text));

      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "Delete";
      deleteBtn.className = "delete-btn";
      deleteBtn.addEventListener("click", () => deleteItem(item.id));
      li.appendChild(deleteBtn);

      return li;
    }

    async function toggleItem(item) {
      if (!item) return;

      // Optimistic update
      item.checked = !item.checked;
      item.order = Date.now(); // Move to top logic
      
      render();

      // Persist
      if (getTableParts()) {
        await updateItemInCloud(item);
      } else {
        // Update local fallback
        const sampleItem = sampleItems.find(i => i.id === item.id);
        if (sampleItem) {
            sampleItem.checked = item.checked;
            sampleItem.order = item.order;
        }
      }
    }

    async function addItemToPartition(partitionKey, inputEl) {
      const text = inputEl.value.trim();
      if (!text) return;

      const newItem = {
        id: Date.now().toString(),
        partitionKey: partitionKey,
        text: text,
        checked: false,
        order: Date.now()
      };

      items.push(newItem);
      inputEl.value = "";
      draftTextByPartition.set(partitionKey, "");
      render();

      if (getTableParts()) {
        await updateItemInCloud(newItem);
      } else {
        sampleItems.push(newItem);
      }
    }

    async function addItemWithPartitionName() {
      const partitionEl = document.getElementById("newPartitionInput");
      const itemEl = document.getElementById("newGlobalItemInput");
      const partitionKey = partitionEl.value.trim();
      if (!partitionKey) return;

      await addItemToPartition(partitionKey, itemEl);
    }

    // Check for edit mode
    if (isEditMode) {
      document.body.classList.add('edit-mode');
    }

    updateGlobalAdderVisibility();

    document.getElementById("addGlobalItemBtn").addEventListener("click", addItemWithPartitionName);
    document.getElementById("newGlobalItemInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") addItemWithPartitionName();
    });
    document.getElementById("newPartitionInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") addItemWithPartitionName();
    });

    // Initial load
    fetchItems();
    
    // Poll every 5 seconds if online, but only when visible to save battery
    setInterval(() => {
      if (!document.hidden && getTableParts()) fetchItems();
    }, 15000);

  </script>

</body>
</html>
